#! /usr/bin/perl

# largest_area

use v5.14; use warnings; use List::AllUtils qw<minmax any max>;

my @range = map { {} } 0..1;
my @edge = map
{
  my @coord = /(\d+)/g;
  @{$range[$_]}{qw<min max>} = minmax $coord[$_], values %{$range[$_]} for 0..1;
  {area_id => ++(state $area_id), coord => \@coord, pos_id => "@coord"},
} <>;

my (%area_size, %done);
undef @area_size{1..$#edge};
while (@edge)
{
  foreach (@edge)
  {
    $area_size{$_->{area_id}}++ if exists $area_size{$_->{area_id}};
    $done{$_->{pos_id}} = 1;
  }
  my %next_edge;
  foreach my $current (@edge)
  {
    foreach my $diff ([-1, 0], [+1, 0], [0, -1], [0, +1])
    {
      my @coord = map { $current->{coord}[$_] + $diff->[$_] } 0..1;
      next if $done{my $pos_id = "@coord"};
      if (any { $coord[$_] < $range[$_]{min} || $coord[$_] > $range[$_]{max} } 0..1)
      {
        delete $area_size{$current->{area_id}};
      }
      elsif (exists $next_edge{$pos_id})
      {
        if ($next_edge{$pos_id}{area_id} ne $current->{area_id})
        {
          delete $next_edge{$pos_id};
          $done{$pos_id} = 1;
        }
      }
      else
      {
        $next_edge{$pos_id} = {area_id => $current->{area_id}, coord => \@coord, pos_id => $pos_id};
      }
    }
  }
  @edge = values %next_edge;
}
say max values %area_size;
