#! /usr/bin/perl

# battle_score

use utf8;
use v5.14;
use warnings;
use experimental qw<signatures>;
use List::AllUtils qw<sort_by min_by sum>;

my $input = do { local $/; <> };
my $map_width = 1 + index $input, "\n";
my (%space, %unit, %type_count);
$space{$-[0]} = 1 while $input =~ /[^#\n]/g;
while ($input =~ s/(\w)/./)
{
  $unit{ $-[0]} = {type => $1, pos => $-[0], power => 3, hit_points => 200};
  $type_count{$1}++;
}

my $completed_rounds = 0;
ROUND: while (1)
{
  foreach (sort_by { $_->{pos} } values %unit)
  {
    next if $_->{hit_points} <= 0; # In case eliminated earlier this round.
last ROUND if keys %unit == $type_count{$_->{type}};
    my $new_pos = next_pos($_->{type}, $map_width, \%space, \%unit, $_->{pos}) or next;
    $unit{$_->{pos} = $new_pos} = delete $unit{$_->{pos}};
    my $target = min_by { $_->{hit_points} } grep { $_ && $_->{type} ne $unit{$new_pos}{type} } map { $unit{$new_pos + $_} } -$map_width, -1, +1, +$map_width or next;
    $target->{hit_points} -= $_->{power};
    if ($target->{hit_points} <= 0)
    {
      $type_count{$target->{type}}--;
      delete $unit{$target->{pos}};
    }
  }
  $completed_rounds++;
}
say $completed_rounds * sum map { $_->{hit_points} } values %unit;

sub next_pos($my_type, $map_width, $space, $unit, $from)
{ 
  my @queue = ({pos => $from});
  my (%tried, @poss_target, @next_queue);
  while (my $here = shift @queue)
  {
    foreach my $Δ (-$map_width, -1, +1, +$map_width)
    {
      my $pos        = $here->{pos} + $Δ;
      push @poss_target, {attack_pos => $here->{pos}, first_step => $here->{first_step} // $here->{pos}} if $unit->{$pos} && $unit->{$pos}{type} ne $my_type;
      push @next_queue,  {pos => $pos, first_step => $here->{first_step} // $pos} if $space->{$pos} && !$unit{$pos} && !$tried{$pos}++;
    }
    (@queue, @next_queue) = (@next_queue, ()) if !@queue && !@poss_target;
  }
  return if !@poss_target;
  (min_by { $_->{attack_pos} } @poss_target)->{first_step};
}
